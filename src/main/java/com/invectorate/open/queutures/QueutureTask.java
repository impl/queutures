package com.invectorate.open.queutures;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;

import com.google.common.base.Preconditions;
import com.google.common.base.Stopwatch;

/*
 * Written by Doug Lea with assistance from members of JCP JSR-166 Expert Group and released to the public domain, as
 * explained at http://creativecommons.org/publicdomain/zero/1.0/
 */

/**
 * An implementation of {@link Queuture} that additionally provides the ability to run a computation.
 * 
 * A {@link BlockingQueue} is used to pass data between the computation and the consumers of this class. Any type of
 * {@link BlockingQueue} is eligible to be used; interesting (but not unintentional) effects can be demonstrated by
 * using, e.g., a {@link SynchronousQueue}.
 * 
 * In addition to serving as a standalone class, this provides {@code protected} functionality that may be useful when
 * creating customized task classes.
 * 
 * @author Noah Fontes <nfontes@invectorate.com>
 * @author Doug Lea
 * 
 * @param <V>
 *            The type of object being generated by the computation.
 */
public class QueutureTask<V> implements RunnableQueuture<V> {

    private final Sync sync;

    /**
     * Create a new {@code QueutureTask} that will execute the given {@link Informable} as its computation, passing
     * results back to this class using the given {@link BlockingQueue}.
     * 
     * The queue passed to this object is required to be empty ({@link BlockingQueue#isEmpty()}). Additionally, it must
     * not be modified in any way outside of this class until {@link #isDone()} returns {@code true}.
     * 
     * @param informable
     *            The computation to execute.
     * @param queue
     *            The queue to use to pass results to this class.
     */
    public QueutureTask(final Informable<QueutureBox<V>> informable, final BlockingQueue<V> queue) {
        Preconditions.checkNotNull(informable, "informable must be specified");
        Preconditions.checkNotNull(queue, "queue must be specified");

        this.sync = new Sync(informable, queue);
    }

    @Override
    public boolean isDone() {
        return this.sync.innerIsDone();
    }

    @Override
    public boolean isCancelled() {
        return this.sync.innerIsCancelled();
    }

    @Override
    public boolean cancel(final boolean mayInterruptIfRunning) {
        return this.sync.innerCancel(mayInterruptIfRunning);
    }

    @Override
    public V next() throws InterruptedException, ExecutionException {
        return this.sync.innerNext();
    }

    @Override
    public V next(final long timeout, final TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return this.sync.innerNext(unit.toNanos(timeout));
    }

    /**
     * Callback method invoked when this task transitions to a done state (whether normally or via cancellation).
     * 
     * The default implementation does nothing. Subclasses may override this method to invoke completion callbacks or
     * perform bookkeeping. Note that you can query status inside the implementation of this method to determine whether
     * this task has been cancelled.
     */
    protected void done() {}

    /**
     * Causes this class to report an {@link ExecutionException} with the given {@link Throwable} as its cause, unless
     * the computation has already completed or has been cancelled.
     * 
     * This method is invoked internally by the {@link #run()} method upon failure of the computation.
     * 
     * @param t
     *            The cause of failure.
     */
    protected void setException(final Throwable t) {
        this.sync.innerSetException(t);
    }

    @Override
    public void run() {
        this.sync.innerRun();
    }

    /**
     * Synchronization control.
     * 
     * The underlying {@link AbstractQueuedSynchronizer}'s state is used to represent the running state of this object.
     * Underlying locks will be released in the following cases:
     * <ul>
     * <li>The computation has completed.</li>
     * <li>The computation has made a new result available on the queue.</li>
     * </ul>
     */
    private final class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 0L;

        /** State value representing that task is ready to run */
        private static final int READY = 0;
        /** State value representing that task is running */
        private static final int RUNNING = 1;
        /** State value representing that task ran */
        private static final int RAN = 2;
        /** State value representing that task was cancelled */
        private static final int CANCELLED = 4;

        /** The underlying callable */
        private final Runnable runnable;
        /** The exception to throw from get() */
        private Throwable exception;

        private final BlockingQueue<V> queue;

        /**
         * The thread running task. Used for interrupting upon receiving a cancellation request.
         */
        private volatile Thread runner;

        Sync(final Informable<QueutureBox<V>> informable, final BlockingQueue<V> queue) {
            this.runnable = new Runnable() {

                @Override
                public void run() {
                    informable.inform(new BoxImpl());
                }

            };
            this.queue = queue;
        }

        private boolean ranOrCancelled(final int state) {
            return (state & (Sync.RAN | Sync.CANCELLED)) != 0;
        }

        /**
         * Whether we should allow consumers to try to read the next result.
         */
        @Override
        protected int tryAcquireShared(final int ignore) {
            return (!this.queue.isEmpty() || this.innerIsDone()) ? 1 : -1;
        }

        /**
         * Wakes up waiting threads to try to read from the queue.
         */
        @Override
        protected boolean tryReleaseShared(final int active) {
            if (active == 0)
                this.runner = null;
            return true;
        }

        boolean innerIsCancelled() {
            return this.getState() == Sync.CANCELLED;
        }

        boolean innerIsDone() {
            return this.ranOrCancelled(this.getState()) && this.runner == null;
        }

        V innerNext() throws InterruptedException, ExecutionException {
            for (;;) {
                this.acquireSharedInterruptibly(0);
                if (this.getState() == Sync.CANCELLED)
                    throw new CancellationException();
                if (this.exception != null)
                    throw new ExecutionException(this.exception);
                /*
                 * Try to get an element from the queue. Could be a spurious wakeup, so ignore the case where we're not
                 * done computing yet.
                 */
                V next = this.queue.poll();
                if (next == null) {
                    if (this.innerIsDone())
                        return null;
                } else {
                    return next;
                }
            }
        }

        V innerNext(final long nanosTimeout) throws InterruptedException, ExecutionException, TimeoutException {
            Stopwatch stopwatch = new Stopwatch().start();
            while (nanosTimeout - stopwatch.elapsedTime(TimeUnit.NANOSECONDS) > 0) {
                if (!this.tryAcquireSharedNanos(0, Math.max(0, nanosTimeout - stopwatch.elapsedTime(TimeUnit.NANOSECONDS))))
                    throw new TimeoutException();
                if (this.getState() == Sync.CANCELLED)
                    throw new CancellationException();
                if (this.exception != null)
                    throw new ExecutionException(this.exception);
                /*
                 * Try to get an element from the queue. Could be a spurious wakeup, so ignore the case where we're not
                 * done computing yet.
                 */
                V next = this.queue.poll();
                if (next == null) {
                    if (this.innerIsDone())
                        return null;
                } else {
                    return next;
                }
            }

            /* Out of time! */
            throw new TimeoutException();
        }

        void innerSetException(final Throwable t) {
            for (;;) {
                int s = this.getState();
                if (s == Sync.RAN)
                    return;
                if (s == Sync.CANCELLED) {
                    // aggressively release to set runner to null,
                    // in case we are racing with a cancel request
                    // that will try to interrupt runner
                    this.releaseShared(0);
                    return;
                }
                if (this.compareAndSetState(s, Sync.RAN)) {
                    this.exception = t;
                    this.releaseShared(0);
                    QueutureTask.this.done();
                    return;
                }
            }
        }

        boolean innerCancel(final boolean mayInterruptIfRunning) {
            for (;;) {
                int s = this.getState();
                if (this.ranOrCancelled(s))
                    return false;
                if (this.compareAndSetState(s, Sync.CANCELLED))
                    break;
            }
            if (mayInterruptIfRunning) {
                Thread r = this.runner;
                if (r != null)
                    r.interrupt();
            }
            this.releaseShared(0);
            QueutureTask.this.done();
            return true;
        }

        void innerRun() {
            if (!this.compareAndSetState(Sync.READY, Sync.RUNNING))
                return;

            this.runner = Thread.currentThread();
            if (this.getState() == Sync.RUNNING) { // recheck after setting thread
                try {
                    this.runnable.run();
                } catch (Throwable ex) {
                    QueutureTask.this.setException(ex);
                    return;
                }

                /* And now we're done. */
                for (;;) {
                    int s = this.getState();
                    if (s == Sync.RAN)
                        return;
                    if (s == Sync.CANCELLED) {
                        // aggressively release to set runner to null,
                        // in case we are racing with a cancel request
                        // that will try to interrupt runner
                        this.releaseShared(0);
                        return;
                    }
                    if (this.compareAndSetState(s, Sync.RAN)) {
                        this.releaseShared(0);
                        QueutureTask.this.done();
                        return;
                    }
                }
            } else {
                this.releaseShared(0); // cancel
            }
        }

        class BoxImpl implements QueutureBox<V> {

            @Override
            public void put(final V object) throws InterruptedException {
                Preconditions.checkNotNull(object, "object must be specified");

                Sync.this.queue.put(object);
                Sync.this.releaseShared(1);
            }

            @Override
            public void put(final V object, final long timeout, final TimeUnit unit) throws TimeoutException, InterruptedException {
                Preconditions.checkNotNull(object, "object must be specified");

                if (!Sync.this.queue.offer(object, timeout, unit))
                    throw new TimeoutException();
                Sync.this.releaseShared(1);
            }

        }

    }

}
